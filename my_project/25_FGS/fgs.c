#include "fgs.h"
/**
  ******************************************************************************
	* @文件名  :一阶互补滤波   
	* @函数介绍:  取a=0~1,本次滤波结果=（1-a）本次采样值+a上次滤波结果
 	* @输入参数: 本次采样值，上次滤波结果，参数a
	* @输出参数:       
	* @备注:优点：对周期性干扰具有良好的抑制作用适用于波动频率较高的场合
  *				缺点：相位滞后，灵敏度低滞后程度取决于a值大小不能消除滤波频率高于采样频率的1/2的干扰信号
  *
  ******************************************************************************
  */
int firstOrderFilter(int newValue, int oldValue, float a)
{
	return a * newValue + (1-a) * oldValue;
}

/**
  ******************************************************************************
	* @文件名  :	 中值滤波算法
	* @函数介绍: 连续采样N次（N取奇数）把N次采样值按大小排列取中间值为本次有效值
 	* @输入参数: 
	* @输出参数:       
	* @备注:优点：能有效克服因偶然因素引起的波动干扰；对温度、液位等变化缓慢的被测参数有良好的滤波效果
  *				缺点：对流量，速度等快速变化的参数不宜
  *
  ******************************************************************************
  */
int middleValueFilter(int N,int* value_buf)
{
    
    int j,k,temp;	
    for(j = 0 ; j < N-1; ++j)
    {
        for(k = 0; k < N-j-1; ++k)
        {
            //从小到大排序，冒泡法排序
            if(value_buf[k] > value_buf[k+1])
            {
                temp = value_buf[k];
                value_buf[k] = value_buf[k+1];
                value_buf[k+1] = temp;
            }
        }
    }
		
    return value_buf[(N-1)/2];
}
/**
  ******************************************************************************
	* @文件名  :	 算术平均值滤波
	* @函数介绍: 连续取N个采样值进行算术平均运算;
	*							N值较大时：信号平滑度较高，但灵敏度较低
	*							N值较小时：信号平滑度较低，但灵敏度较高、
	*							N值的选取：一般流量，N=12；压力：N=4
 	* @输入参数: 
	* @输出参数:       
	* @备注:优点：试用于对一般具有随机干扰的信号进行滤波。这种信号的特点是有一个平均值，信号在某一数值范围附近上下波动。
  *				缺点：测量速度较慢或要求数据计算较快的实时控制不适用。
  *
  ******************************************************************************
  */
int averageFilter(int N, int* input)
{
   int sum = 0;
   short i;
   for(i = 0; i < N; ++i)
   {
        sum += input[i];
   }
   return sum/N;
}
/**
  ******************************************************************************
	* @文件名  :	 平滑均值滤波
	* @函数介绍: 把连续取N个采样值看成一个队列，队列的长度固定为N。每次采样到一个新数据放入队尾，
	*					   并扔掉原来队首的一次数据(先进先出原则)。把队列中的N个数据进行算术平均运算,就可获得新的滤波结果。
	*							N值的选取：流量，N=12；压力：N=4；液面，N=4~12；温度，N=1~4						
 	* @输入参数:  N 表示队列长度
	*						 input 表示输入数据,
	* 				   value_buf 是一个指向存储历史数据的数组的指针
	*            sum 表示历史数据的和
  *       	 	 curNum 表示当前已存储的数据数量。
	* @输出参数:       
	* @备注:优点：对周期性干扰有良好的抑制作用，平滑度高；试用于高频振荡的系统
  *				缺点：灵敏度低；对偶然出现的脉冲性干扰的抑制作用较差，不适于脉冲干扰较严重的场合
	*		  				比较浪费RAM（改进方法，减去的不是队首的值，而是上一次得到的平均值）
  *
  ******************************************************************************
  */
int moveAverageFilter(int N,int input, int* value_buf, int* sum, int* curNum)
{
    if(*curNum < N)
    {
        value_buf[*curNum] = input;
        *sum += value_buf[*curNum];
        (*curNum)++;
        return *sum / *curNum;
    }
    else
    {
        *sum -= *sum / N;
        *sum += input;
        return *sum / N;
    }
}

/**
  ******************************************************************************
	* @文件名  :	 限幅平均滤波
	* @函数介绍: 相当于“限幅滤波法”+“递推平均滤波法”
	*            每次采样到的新数据先进行限幅处理再送入队列进行递推平均滤波处理
 	* @输入参数: 
	* @输出参数:       
	* @备注:优点：对于偶然出现的脉冲性干扰，可消除有其引起的采样值偏差。
  *				缺点：比较浪费RAM
	*		  		
  ******************************************************************************
  */
#define A 50        //限制幅度阈值
#define M 12
int LAverageFilter(int input, int* data, int* flag)
{
    int i;
    int temp, sum = 0;
    if (*flag == 0) 
		{
        data[0] = input;
        for (i = 1; i < M; i++) 
			  {
            data[i] = input;
        }
        *flag = 1;
        return input;
    }
    else 
		{
        for (i = M-1; i > 0; i--) 
			  {
            data[i] = data[i-1];
        }
        temp = input;
        if ((temp - data[M-2]) > A || ((data[M-2] - temp) > A)) 
				{
            *flag += 1;
        }
        else 
				{
            data[0] = temp;
        }

        for (i = 0; i < M; i++) 
				{
            sum += data[i];
        }
        return sum / M;
    }
}


/**
  ******************************************************************************
	* @文件名  :	 卡尔曼滤波
	* @函数介绍:		核心思想：根据当前的仪器"测量值" 和上一刻的 “预测量” 和 “误差”，
	*							计算得到当前的最优量，再预测下一刻的量。里面比较突出的是观点是：把误差纳入计算，
	*							而且分为预测误差和测量误差两种，通称为噪声。还有一个非常大的特点是：误差独立存在，
	*							始终不受测量数据的影响。
	*	
 	* @输入参数: 
	* @输出参数:       
	* @备注:优点：巧妙的融合了观测数据与估计数据，对误差进行闭环管理，将误差限定在一定范围。适用性范围很广，时效性和效果都很优秀。
  *				缺点：需要调参，参数的大小对滤波的效果影响较大。
	*		  		
  ******************************************************************************
  */
//int KalmanFilter(int inData)
//{
//		static float prevData = 0;                                 //先前数值
//		static float p = 10, q = 0.001, r = 0.001, kGain = 0;      // q控制误差  r控制响应速度 
//	
//		p = p + q;
//		kGain = p / ( p + r );                                     //计算卡尔曼增益
//		inData = prevData + ( kGain * ( inData - prevData ) );     //计算本次滤波估计值
//		p = ( 1 - kGain ) * p;                                     //更新测量方差
//		prevData = inData;
//		return inData;                                             //返回滤波值
//}
float KalmanFilter(int inData, KalmanParams* params)
{
    params->p = params->p + params->q;
    params->kGain = params->p / (params->p + params->r);
    inData = params->prevData + (params->kGain * (inData - params->prevData));
    params->p = (1 - params->kGain) * params->p;
    params->prevData = inData;
    return inData;
}
